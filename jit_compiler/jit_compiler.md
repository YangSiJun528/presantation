---
marp: true
---

# **JIT(Just In Time) Compiler**
###### Java BE 양시준

<!--
안녕하세요. 
Just In Time Compiler라는 주제로 발표하게된.
자바 벡엔드 양시준입니다. 반갑습니다.

발표 주제를 많이 고민했었는데,
여러 분야의 사람들이게 유익했으면 해서
많은 프로그래밍 언어에서 사용되는 
Just In Time Compiler라는 개념을 주제를
결정했습니다.

그럼 발표 시작하겠습니다.
-->
- - -
<style scoped>
li{
  font-size: 28px;
}
</style>
# 컴파일러, 인터프리터
- #### 컴파일러(Compiler)
    - 소스 코드를 한 번에 전체를 읽고, 중간 언어 혹은 기계어로 변환
        - 컴파일 시, 여러 최적화(Optimization)를 진행
    - 빠름
    - C/C++
- #### 인터프리터(Interpreter)
    - 소스 코드를 한 줄씩 기계어로 변역하고 실행
    - 느림
    - Python, JavaScript

<!--
Just In Time 컴파일러를 설명하기 앞서서
컴파일러, 인터프리터가 무엇인지 알아야 하는데요.

컴파일러는 소스 코드를 한 번에 전체를 읽고, 중간 언어 혹은 기계어로 변환합니다.
컴파일 과정에서 여러 최적화를 진행합니다.
이미 기계어로 변역된 프로그램을 실행하기 때문에 빠릅니다.
대표적인 컴파일러 언어로 C, C++가 존재합니다.

인터프리터에 관한 특징은 다음 페이지에서 더 자세히 다루므로 생략하고요.
대표적인 인터프리터 언어로 Python, JavaScript가 있습니다.

...

(이 부분 말 안할꺼임)
그리고 주제와 약간 벗어난 이야기지만,
여기서 편의를 위해 컴파일러 언어, 인터프리터 언어가 존재하는 것처럼 말했지만,
특정 프로그래밍 언어를 컴파일러 언어다. 
혹은, 인터프리터 언어다 라고 구분하는 건 의미가 없습니다.
어떤 프로그래밍 언어도 컴파일러나 인터프리터로 동작할 수 있어요.
이에 관해선 다음에 기회가 되면 다루도록 하겠습니다.

...


-->
- - -

# 인터프리터 언어의 문제점

### 느리다.

코드를 한 줄씩 읽고 해석하기 때문에 컴파일러에 비해 느리다.
애플리케이션 실행 시간과 최적화 사이의 트레이오프가 발생한다.
ex) 특정 코드 N번 반복 시, N번 읽고 기계어로 번역 해야 함

속도 문제를 해결하기 위해서 **Jit Compiler**가 등장

\- \- \-

자바나 C#처럼 미리 컴파일된 중간 언어와 가상머신을 사용하는 언어도 
컴파일 과정을 거치지만 실행 단계에서 인터프리터와 같은 특성을 가지고 있다.
따라서 동일한 문제를 가지고 있고, Jit Compiler를 사용한다.

<!--
인터프리터 언어의 대표적인 문제점은 느리다는 겁니다.

인터프리터는 
코드를 한 줄씩 읽고 해석하는 과정을 거쳐야 합니다.
따라서 기계어로 컴파일 된 실행 파일을 실행하는 컴파일러 방식에 비해 느립니다.

또한 인터프리터 과정은 런타임에 진행됩니다. 
인터프리터 과정이 늦어질 수록 프로그램 속도가 늦춰지기 때문에
애플리케이션 실행 시간과 인터프리터의 최적화 정도는 반비례합니다.
따라서 많은 시간을 최적화에 할애 할 수 없고,
이 역시 실행 속도에 영향을 줍니다.

그래서 
느린 속도 문제를 해결하기 위한 여러 기법이 등장했는데
그 중에 하나가 Just In Time 컴파일러입니다.

...

그리고 
자바나 C#처럼 미리 컴파일된 중간 언어와 가상머신을 사용하는 언어도 
컴파일 과정을 거치지만 실행 단계에서 인터프리터와 같은 특성을 가진다.
따라서 동일한 문제를 가지고 있고, 문제를 해결하기 위해 Just In Time 컴파일러를 사용합니다.
-->
- - -

<!-- <style scoped>
p{
  font-size: 26px;
}
</style> -->

# JIT(Just In Time) Compiler란?

런타임 환경에서 자주 사용되는 코드를 추적, 컴파일, 캐싱하는 컴파일러.

실행 전에 모든 코드를 미리 컴파일하지 않고, 실제 실행 시 필요한 부분만을 컴파일하여 실행한다.

컴파일 시 **최적화**를 진행한다.

**런타임** 시점에 컴파일을 수행하기 때문에 **JIT(Just In Time) Compiler**라고 부른다.

기존의 미리 컴파일하고 프로그램을 실행하는 방식은 AOT(Ahead Of Time) Compiler라고 부른다.


<!--
Just In Time 컴파일러란,

런타임 환경에서 자주 사용되는 코드를 추적하고 컴파일하고, 
컴파일 한 결과를 캐싱하여 재사용하는 기술을 제공하는 컴파일러입니다.

실행 전에 모든 코드를 미리 컴파일하지 않고, 실제 실행 시 필요한 부분만을 컴파일하여 실행합니다.

컴파일 시에 최적화를 진행합니다.

프로그램 실행 중인 런타임 시점에 코드를 컴파일하기 때문에 
Just In Time 컴파일러 라고 부릅니다.

Just In Time 컴파일러와 혼동되지 않기 위해서 
기존의 컴파일러, 그러니까 미리 컴파일하여 실행파일을 만들고
프로그램을 실행하는 방식은 Ahead Of Time 컴파일러라고 부릅니다.

-->

- - -

# JIT Compiler 장단점
<style scoped>
p, li{
  font-size: 26px;
}
</style>

#### 장점
인터프리터의 특징을 유지하면서 높은 성능을 가진다.

#### 단점
최적화 과정이 필요하다.
- 새로 프로그램을 실행하는 경우, 하나도 컴파일이 되어있지 않다.
    -   자주 실행되는 코드가 컴파일 되기 전까지 Latency가 발생한다.
- 사용자에게 제공하기 전 Warm Up을 하기도 한다.

작은 규모의 프로그램에서 유효하지 않다.
- Script, 간단한 로직을 가지는 경우 

<!--
Just In Time 컴파일러의 장점으로는
인터프리터의 특징을 유지하면서 단점인 낮은 속도를 해결해주어 
높은 성능을 가진다는 점이고요.

(이부분 말 안함) 인터프리터의 장점 - 메모리 사용량이 적다. - 프로그램 시작 시간이 짦다.

단점으로는 최적화 과정이 필요합니다.

새로 프로그램을 실행하는 경우, 

아무 코드도 컴파일되어 있지 않은 상태입니다.

자주 실행되는 코드라고 하더라도  
컴파일 되기 전까지 인터프리터 방식으로 동작하므로
레이턴시가 발생할 수 있습니다.

그래서 서버의 경우에는
새로 프로그램을 실행했을 때,
클라이언트에게 제공하기 전
실제와 비슷한 요청을 발생시켜 미리 컴파일 하는
Warm Up을 수행하기도 합니다.

또, 작은 규모의 프로젝트에 유효하지 않다는 단점이 있는데요.
자동화 스크립트나 간단한 로직을 가지는 프로젝트의 경우에는 
컴파일을 해야 할 정도로 최적화가 필요하지 않기 때문입니다.
-->

- - -

# JIT Compiler를 사용하는 언어

인터프리터 혹은 중간 언어와 가상머신을 사용하는 프로그래밍 언어 대부분

- Java - OpenJDK
- C#
- JavaScript - V8, Node.js
- Python - pypy
    - 공식 구현체인 python3는 사용하지 않는다.

<!-- 
Just In Time 컴파일러를 사용하는 언어로는
인터프리터 혹은 중간 언어와 가상머신을 사용하는 
프로그래밍 언어 대부분이 사용하고 있습니다.

대표적으로 자바, C#, 자바스크립트, 파이썬 등이 있습니다.
파이썬의 경우에 공식 구현체인 python3는
Just In Time 컴파일러를 사용하지 않고요.
pypy(파이파이)라는 구현체가 Just In Time 컴파일러를 제공하고 있습니다.


(이 부분 생략) 개인적인 의견이지만,
아마 파이썬의 공식 구현체인 python3가 
Just In Time 컴파일러를 제공하지 않는 이유는
파이썬이 스크립트나 가벼운 프로그램으로 사용되는 경우가 
많기 때문일 수도 있다고 생각합니다.
-->
- - -

# JIT Compiler 테스트

Python으로 테스트

JIT Compiler를 구현하는 `pypy`와
JIT Compiler를 구현하지 않는 `python3` 사용

로컬 환경에서 실행

Loop 횟수(100만 ~ 10억) 실행시간 비교

```python
def add(x,y):
    return x + y
    
for _ in range(1000000000):
    num += add(1,2)

print(num)
```
<!-- 
Just In Time Compiler를 직접 테스트 해보았는데요.

Just In Time Compiler를 구현하는 `pypy`와
Just In Time Compiler를 구현하지 않는 `python3`를 사용하여
동일한 코드의 수행시간을 비교하였습니다.

사용할 코드는
보시는 것처럼 단순하게 add() 라는 
함수를 반복 호출하는 코드입니다.

반복문의 반복 횟수를 증가시켜가면서 비교하였습니다.
-->
- - -

# JIT Compiler 테스트 결과
 
![w:600](svg.svg) 

|Python 구현체\Loop 횟수|100만|1000만|1억|10억|
|---|---|---|---|---|
|**pypy JIT on**|0.02s|0.05s|0.26s|2.22s|
|**pypy JIT off**|0.18s|1.68s|17.03s|167.94s|
|**python3**|0.10s|0.76s|7.60s|77.81s|

<style scoped>
table {
  font-size: 16px;
}
</style>

<!--
$\frac{{2.22}}{{77.81}} \approx 0.0285$ → 2.85% 시간 소요 (python3, JIT 사용한 pypy 비교 시, 10억회 기준) 

보시는 것과 같은 결과가 발생했습니다.

우선 결과를 비교하기 전에 말씀드리고 싶은게 있는데
python3와 pypy 간에는 여러 차이가 존재하기 때문에
실행 시간 차이가 온전히 JUST IN TIME 컴파일러에 의한 건 아닐 수도 있습니다.

...

결과를 설명하자면,
빨간색이 pypy에서 JUST IN TIME 컴파일러 옵션을 사용한 경우,
파란색이 pypy에서 JUST IN TIME 컴파일러 옵션을 사용하지 않는 경우
하늘색이 python3를 실행한 경우를 나타냅니다.

반복 횟수가 1억을 넘기 시작하면서 
시간 차이가 크게 벌어지는 모습을 확인할 수 있습니다.

또한 이 차이는 반복 횟수가 증가할수록 벌어지는 모습을 보여줍니다.

이처럼 JUST IN TIME 컴파일러를 사용하면 
JUST IN TIME 컴파일러를 사용하지 않는 것보다
높은 성능을 얻을 수 있다는 걸 확인 할 수 있습니다.
-->
--- 

# 정리
- JIT Compiler는 런타임 환경에서 컴파일을 수행한다.
- JIT Compiler는 인터프리터의 장점을 유지하면서 높은 성능을 가지게 해준다.

<!-- 
마지막으로 정리해보자면, JUST IN TIME 컴파일러는
런타임 환경에서 컴파일을 수행하는 컴파일러이고,
인터프리터의 장점을 유지하면서 높은 성능을 가질 수 있습니다.

이상으로 발표를 마치겠습니다.

혹시 질문 있으신분 계실까요?

...

시간이 약간 남아서, 제가 방금 보여드렸던 테스트를 직접
실행하는 모습을 보여드리고 끝내도록 하겠습니다.
-->